{
As credenciais do ambiente de homologação já foram criadas, segue abaixo:
Client Key: 9693f06b-b929-4a9c-8182-e25270c4029d
Client Secret: 7cb3d3eb-a2c9-4084-8e03-72230000b4dd

https://slproweb.com/products/Win32OpenSSL.html
}

unit uOxymed;

interface

uses

  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, IdHTTP, IdSSL, IdSSLOpenSSL,
  Vcl.StdCtrls,  IdGlobal,   System.JSON,
  System.Net.HttpClient, System.Net.URLClient,
  Winapi.ShellAPI,
  System.Net.HttpClientComponent,
  System.NetEncoding,
  System.IOUtils,
  System.Diagnostics;

type
  TBradesco = class
  private
    FRazaoSocial: string;
    FClienteID: Integer;
    FCNPJ: string;
    FCertificadoDigital: string;
    FConta: String;
    FAgencia: String;
    FJWS:String;
    FToken:String;
    function CriarHeader: string;
    function CriarPayload: string;
    function ClientKey:String;
    function APIToken:String;
    function CodificarBase64(const Texto: string): string;
    function GerarAssinatura(const JWS: string): string;
    function MontarJWS: string;
    function ObterBearerToken(const JWS: string): string;
    function GerarToken:String;
    procedure ExecutarComando(const Comando: string);
  public
    constructor Create;
    property RazaoSocial: string read FRazaoSocial write FRazaoSocial;
    property ClienteID: Integer read FClienteID write FClienteID;
    property CNPJ: string read FCNPJ write FCNPJ;
    property CertificadoDigital: string read FCertificadoDigital
      write FCertificadoDigital;
    property Conta: string read FConta write FConta;
    property Agencia: string read FAgencia write FAgencia;
    function Extrato(Inicio, Fim: TDateTime): String;
  end;

implementation

function TBradesco.APIToken: String;
begin
  result :=  'https://proxy.api.prebanco.com.br/auth/server/v1.1/token';
end;

function TBradesco.ClientKey: String;
begin
   result := '9693f06b-b929-4a9c-8182-e25270c4029d';
end;

function TBradesco.CodificarBase64(const Texto: string): string;
begin
   Result := TNetEncoding.Base64.Encode(Texto);
end;

constructor TBradesco.Create;
begin
  FJWS := Self.MontarJWS;
//  FToken := self.GerarToken;
end;

function TBradesco.CriarHeader: string;
var
  Header: TJSONObject;
begin
  Header := TJSONObject.Create;
  try
    Header.AddPair('alg', 'RS256');
    Header.AddPair('typ', 'JWT');
    Result := Header.ToString;
  finally
    Header.Free;
  end;
end;

function TBradesco.CriarPayload: string;
var
  Payload: TJSONObject;
  IAT, EXP, JTI: Int64;  // Alterado para Int64  // Integer;
begin
  // Obter o timestamp atual em segundos
  IAT := Trunc(Now * 86400) + 25569; // Converte de "tData" para timestamp em segundos
  EXP := IAT + 3600; // Expiração de 1 hora
  JTI := IAT * 1000; // jti em milissegundos

  Payload := TJSONObject.Create;
  try
    Payload.AddPair('aud', self.APIToken);
    Payload.AddPair('sub', self.ClientKey);
    Payload.AddPair('iat', IAT);
    Payload.AddPair('exp', EXP);
    Payload.AddPair('jti', JTI);
    Payload.AddPair('ver', '1.1');
    Result := Payload.ToString;
  finally
    Payload.Free;
  end;
end;

procedure TBradesco.ExecutarComando(const Comando: string);
var
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  Cmd: string;
begin
  // Inicializa as estruturas
  ZeroMemory(@StartupInfo, SizeOf(StartupInfo));
  StartupInfo.cb := SizeOf(StartupInfo);

  // Comando a ser executado
  Cmd := 'cmd.exe /c ' + Comando; // O /c executa e fecha o cmd após a execução

  // Cria o processo e executa o comando
  if not CreateProcess(nil, PChar(Cmd), nil, nil, False, 0, nil, nil, StartupInfo, ProcessInfo) then
    RaiseLastOSError; // Caso ocorra erro

  // Aguarda o processo terminar
  WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
  CloseHandle(ProcessInfo.hProcess);
  CloseHandle(ProcessInfo.hThread);
end;


function TBradesco.Extrato(Inicio, Fim: TDateTime): String;
var
  HttpClient: THTTPClient;
  Response: IHTTPResponse;
  StringStream: TStringStream;
  JsonBody, FormBody: string;
  JsonResponse: TJSONObject;
begin
  HttpClient := THTTPClient.Create;
  try
     // Configuração do TLS 1.2 (se necessário)
    HttpClient.AcceptEncoding := 'gzip, deflate';
    HttpClient.UserAgent := 'Delphi HTTP Client';

    // Configurar os headers personalizados (por exemplo, token Bearer)
    //HttpClient.CustomHeaders['Authorization'] := 'Bearer ' + self.FJWS;  // O seu JWS ou token JWT
    HttpClient.CustomHeaders['Content-Type'] := 'application/x-www-form-urlencoded'; // ou 'application/json' dependendo da API

    // Definir os cabeçalhos necessários
    HttpClient.CustomHeaders['Content-Type'] := 'application/x-www-form-urlencoded'; // Formato esperado pela API

    // Montar o corpo da requisição com os parâmetros necessários
    FormBody := 'grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=' + self.FJWS;

    // Criar o StringStream a partir do corpo da requisição
    StringStream := TStringStream.Create(FormBody, TEncoding.UTF8);

    try
      // Realizando a requisição GET
      Response := HttpClient.Post(self.APIToken, StringStream);

      // Verificando a resposta
      if Response.StatusCode = 200 then
      begin
        // Se a resposta for bem-sucedida, processar o JSON
        JsonResponse := TJSONObject.ParseJSONValue(Response.ContentAsString) as TJSONObject;
        try
          // Verificar se o campo "access_token" existe
          if Assigned(JsonResponse) and JsonResponse.GetValue('access_token') <> nil then
          begin
            // Retornar o Bearer Token
            Result := JsonResponse.GetValue('access_token').Value;
          end
          else
          begin
            // Se o campo "access_token" não for encontrado
            Result := 'Erro: "access_token" não encontrado na resposta.';
          end;
        finally
          JsonResponse.Free;
        end;
end;
      // A resposta será recebida diretamente
      Result := Response.ContentAsString;
    except
      on E: Exception do
      begin
        Result := 'Erro: ' + E.Message;
      end;
    end;
  finally
    HttpClient.Free;
  end;
end;

function TBradesco.GerarAssinatura(const JWS: string): string;
var
  Cmd, OutputFile, InputFile: string;
//  Process: TProcess;
begin
  // Salva o JWS (Header + Payload) em um arquivo temporário
  InputFile := 'C:\wander\assinaturas\jwt.txt';
  OutputFile := 'C:\wander\assinaturas\signature.txt';

  // Cria o arquivo com o conteúdo do JWS
  TFile.WriteAllText(InputFile, JWS);

  // Monta o comando para executar o OpenSSL
  Cmd := 'openssl dgst -sha256 -keyform pem -sign chaves\privada\oxymed.homologacao.key.pem -out ' + OutputFile + ' ' + InputFile;

  // Executa o comando
  ShellExecute(0, 'open', 'cmd.exe', PChar('/c ' + Cmd), nil, SW_HIDE);

  // Lê a assinatura gerada
  Result := TFile.ReadAllText(OutputFile);
end;

function TBradesco.GerarToken:String;
var
  JWS, BearerToken: string;
begin
  // Criar o JWS
  JWS := MontarJWS;

  // Obter o Bearer Token
  BearerToken := ObterBearerToken(JWS);

  // Exibir o Bearer Token
  self.FToken := BearerToken;
end;

function TBradesco.MontarJWS: string;
var
  Header, Payload, Signature: string;
begin
  Header := CriarHeader;
  Payload := CriarPayload;

  // Codifica o Header e Payload em Base64
  Header := CodificarBase64(Header);
  Payload := CodificarBase64(Payload);

  // Gera a assinatura (JWS)
  Signature := GerarAssinatura(Header + '.' + Payload);

  // Concatena tudo para formar o JWS completo
  Result := Header + '.' + Payload + '.' + Signature;
end;

function TBradesco.ObterBearerToken(const JWS: string): string;
var
  HttpClient: THttpClient;
  Response: IHTTPResponse;
  Params: TStringList;
begin
  HttpClient := THttpClient.Create;
  Params := TStringList.Create;
  try
    // Definir os parâmetros do corpo da requisição
    Params.Add('grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer');
    Params.Add('assertion=' + JWS);

    // Definir os cabeçalhos da requisição
    HttpClient.ContentType := 'application/x-www-form-urlencoded';

    // Enviar a requisição POST para obter o Bearer Token
    Response := HttpClient.Post('https://homologacao/auth/server/v1.1/token', Params);

    // Retornar o corpo da resposta, que deve ser o Bearer Token
    Result := Response.ContentAsString();
  finally
    HttpClient.Free;
    Params.Free;
  end;
end;
end.
